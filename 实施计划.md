# API密钥管理系统重构实施计划

## 项目概述

本次重构将对现有的API密钥管理系统进行全面改造，主要目标包括：
1. 移除管理员服务，实现纯用户自助服务模式
2. 注册时强制进行TOTP认证
3. 增强用户功能模块（日志、IP记录、余额管理等）
4. 优化数据库结构，确保SQLite兼容性

## 重构目标

### 功能目标
- ✅ 移除管理员角色和功能
- ✅ 注册时自动启用TOTP认证
- ✅ 用户可独立管理所有功能
- ✅ 增强用户操作日志查看
- ✅ 添加IP地址和地理位置记录
- ✅ 实现Token使用统计和追踪
- ✅ 完善余额管理和续费功能

### 技术目标
- ✅ 完全兼容SQLite数据库
- ✅ 优化数据库查询性能
- ✅ 增强系统安全性
- ✅ 提升用户体验

## 详细实施计划

### 阶段1: 数据库重构 (1-2天)

#### 1.1 创建新的数据库迁移脚本
**任务清单**:
- [ ] 创建 `backend/sql/migrate_add_balance_tables.sql` - 余额相关表
- [ ] 创建 `backend/sql/migrate_add_usage_tracking.sql` - 使用追踪表
- [ ] 创建 `backend/sql/migrate_add_security_features.sql` - 安全功能表
- [ ] 更新 `backend/sql/create_tables.sql` - 添加索引优化

**文件内容**:
```sql
-- backend/sql/migrate_add_balance_tables.sql
CREATE TABLE IF NOT EXISTS user_balances (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    provider_id INTEGER NOT NULL,
    balance REAL DEFAULT 0,
    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (provider_id) REFERENCES api_providers(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS balance_change_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    balance_type VARCHAR(20),
    amount REAL,
    balance_before REAL,
    balance_after REAL,
    reference_id INTEGER,
    reference_type VARCHAR(50),
    notes TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS subscription_renewals (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    subscription_type VARCHAR(20),
    amount REAL,
    payment_method VARCHAR(50),
    status VARCHAR(20) DEFAULT 'pending',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 添加索引
CREATE INDEX IF NOT EXISTS idx_user_balances_user_id ON user_balances(user_id);
CREATE INDEX IF NOT EXISTS idx_user_balances_provider_id ON user_balances(provider_id);
CREATE INDEX IF NOT EXISTS idx_balance_change_logs_user_id ON balance_change_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_subscription_renewals_user_id ON subscription_renewals(user_id);
```

#### 1.2 更新数据模型定义
**任务清单**:
- [ ] 更新 `backend/models.py` - 添加新的数据模型
- [ ] 更新 `backend/schemas.py` - 添加新的数据验证模型
- [ ] 更新 `backend/database.py` - 确保SQLite兼容性

**新增模型**:
```python
# backend/models.py
class UserBalance(Base):
    __tablename__ = "user_balances"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    provider_id = Column(Integer, ForeignKey("api_providers.id", ondelete="CASCADE"), nullable=False, index=True)
    balance = Column(Float, default=0.0)
    last_updated = Column(TIMESTAMP, default=datetime.utcnow)
    
    user = relationship("User")
    provider = relationship("ApiProvider")

class APIUsageLog(Base):
    __tablename__ = "api_usage_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    api_key_id = Column(Integer, ForeignKey("user_api_keys.id", ondelete="SET NULL"))
    provider_id = Column(Integer, ForeignKey("api_providers.id"))
    model_id = Column(String(100))
    tokens_used = Column(Integer, default=0)
    cost = Column(Float, default=0.0)
    status = Column(String(20), default="success")
    error_message = Column(Text)
    created_at = Column(TIMESTAMP, default=datetime.utcnow, index=True)

class SubscriptionRenewal(Base):
    __tablename__ = "subscription_renewals"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    subscription_type = Column(String(20))
    amount = Column(Float)
    payment_method = Column(String(50))
    status = Column(String(20), default="pending")
    created_at = Column(TIMESTAMP, default=datetime.utcnow, index=True)

class IPLocationRecord(Base):
    __tablename__ = "ip_location_records"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    ip_address = Column(String(45), nullable=False, index=True)
    location = Column(String(200))
    country = Column(String(100))
    region = Column(String(100))
    city = Column(String(100))
    latitude = Column(Float)
    longitude = Column(Float)
    user_agent = Column(Text)
    created_at = Column(TIMESTAMP, default=datetime.utcnow, index=True)
```

#### 1.3 测试数据库操作
**任务清单**:
- [ ] 创建数据库测试脚本
- [ ] 测试SQLite连接和操作
- [ ] 验证数据完整性约束
- [ ] 性能测试和优化

### 阶段2: 认证流程重构 (1天)

#### 2.1 修改注册流程
**任务清单**:
- [ ] 更新注册API，强制TOTP
- [ ] 修改前端注册页面
- [ ] 添加TOTP密钥显示
- [ ] 测试注册流程

**修改内容**:
```python
# backend/routers/auth.py
@router.post("/register", response_model=MessageResponse)
@limiter.limit("5/hour")
def register(request: Request, user_data: UserCreate, db: Session = Depends(get_db)):
    # 检查用户名和邮箱是否已存在
    if db.query(User).filter(User.username == user_data.username).first():
        raise HTTPException(status_code=400, detail="Username already registered")
    
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # 创建用户（TOTP已启用）
    hashed_password = get_password_hash(user_data.password)
    new_user = User(
        username=user_data.username,
        email=user_data.email,
        password_hash=hashed_password,
        is_active=True,
        # 注册时自动启用TOTP
        totp_enabled=True
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    # 为用户生成TOTP密钥
    secret = generate_totp_secret()
    enable_totp_for_user(db, new_user.id, secret)
    
    return MessageResponse(message="User registered successfully with TOTP enabled", success=True)
```

#### 2.2 优化登录流程
**任务清单**:
- [ ] 更新登录API，强制TOTP验证
- [ ] 修改前端登录页面
- [ ] 添加TOTP输入字段
- [ ] 测试登录流程

**修改内容**:
```python
@router.post("/login", response_model=Token)
@limiter.limit("10/minute")
def login(request: Request, user_data: UserLogin, db: Session = Depends(get_db)):
    # 验证码检查（生产环境）
    if CAPTCHA_ENABLED:
        if not user_data.captcha_token or not user_data.captcha_answer:
            raise HTTPException(status_code=400, detail="验证码不能为空")
        if not verify_captcha(user_data.captcha_token, user_data.captcha_answer):
            raise HTTPException(status_code=400, detail="验证码错误或已过期")
    
    # 查找用户
    user = db.query(User).filter(User.username == user_data.username).first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 检查账户是否被锁定
    if user.locked_until and user.locked_until > datetime.utcnow():
        raise HTTPException(status_code=400, detail="Account is temporarily locked")
    
    # 验证密码
    if not verify_password(user_data.password, user.password_hash):
        # 增加登录尝试次数
        user.login_attempts = (user.login_attempts or 0) + 1
        
        # 5次失败后锁定账户30分钟
        if user.login_attempts >= 5:
            user.locked_until = datetime.utcnow() + timedelta(minutes=30)
            db.commit()
            raise HTTPException(status_code=400, detail="Account locked for 30 minutes due to too many failed attempts")
        
        db.commit()
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 验证TOTP令牌
    if not user_data.totp_token:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="TOTP verification required"
        )
    
    is_totp_valid, totp_message = verify_totp_token(db, user.id, user_data.totp_token)
    if not is_totp_valid:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=totp_message
        )
    
    # 重置登录尝试次数
    user.login_attempts = 0
    user.locked_until = None
    user.last_login = datetime.utcnow()
    
    db.commit()
    
    # 创建访问令牌
    access_token = create_access_token(data={"sub": user.username})
    
    return Token(
        access_token=access_token,
        user=UserResponse(
            id=user.id,
            username=user.username,
            email=user.email,
            is_active=user.is_active,
            role=user.role,
            membership_tier=user.membership_tier or 'free',
            membership_expire_at=user.membership_expire_at,
            membership_started_at=user.membership_started_at,
            created_at=user.created_at,
            last_login=user.last_login
        )
    )
```

#### 2.3 更新TOTP相关API
**任务清单**:
- [ ] 创建TOTP管理API
- [ ] 更新TOTP验证逻辑
- [ ] 测试TOTP功能
- [ ] 添加TOTP日志记录

### 阶段3: 用户功能开发 (3-4天)

#### 3.1 开发余额管理功能
**任务清单**:
- [ ] 创建余额管理API
- [ ] 实现余额查询和更新
- [ ] 添加余额变更日志
- [ ] 创建余额管理前端页面

**API实现**:
```python
# backend/routers/balance.py
router = APIRouter(prefix="/api/balance", tags=["balance"])

@router.get("", response_model=List[UserBalanceResponse])
def get_user_balances(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的余额信息"""
    balances = db.query(UserBalance).filter(
        UserBalance.user_id == current_user.id
    ).all()
    
    # 添加服务商信息
    for balance in balances:
        provider = db.query(ApiProvider).filter(
            ApiProvider.id == balance.provider_id
        ).first()
        balance.provider_name = provider.display_name if provider else ""
    
    return balances

@router.post("/renew", response_model=MessageResponse)
def renew_subscription(
    request: Request,
    subscription_type: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """续费会员"""
    # 创建续费记录
    renewal = SubscriptionRenewal(
        user_id=current_user.id,
        subscription_type=subscription_type,
        amount=calculate_subscription_amount(subscription_type),
        status="pending"
    )
    db.add(renewal)
    db.commit()
    
    # 触发支付流程
    payment_url = initiate_payment(renewal.id, subscription_type)
    
    return MessageResponse(
        message="Renewal initiated successfully",
        success=True
    )
```

#### 3.2 开发使用统计功能
**任务清单**:
- [ ] 创建使用统计API
- [ ] 实现Token使用追踪
- [ ] 添加使用历史查询
- [ ] 创建使用统计前端页面

**API实现**:
```python
# backend/routers/usage.py
router = APIRouter(prefix="/api/usage", tags=["usage"])

@router.get("/statistics", response_model=UsageStatisticsResponse)
def get_usage_statistics(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的使用统计"""
    # 获取本月使用情况
    from datetime import datetime, timedelta
    start_of_month = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    
    monthly_usage = db.query(
        func.sum(APIUsageLog.tokens_used).label("total_tokens"),
        func.sum(APIUsageLog.cost).label("total_cost"),
        func.count(APIUsageLog.id).label("total_calls")
    ).filter(
        APIUsageLog.user_id == current_user.id,
        APIUsageLog.created_at >= start_of_month
    ).first()
    
    # 按服务商统计
    provider_stats = db.query(
        ApiProvider.display_name,
        func.sum(APIUsageLog.tokens_used).label("tokens_used"),
        func.sum(APIUsageLog.cost).label("cost")
    ).join(APIUsageLog).filter(
        APIUsageLog.user_id == current_user.id
    ).group_by(ApiProvider.id).all()
    
    return {
        "monthly_usage": {
            "total_tokens": monthly_usage.total_tokens or 0,
            "total_cost": monthly_usage.total_cost or 0,
            "total_calls": monthly_usage.total_calls or 0
        },
        "provider_stats": [
            {"provider": name, "tokens_used": tokens, "cost": cost}
            for name, tokens, cost in provider_stats
        ]
    }
```

#### 3.3 开发安全设置功能
**任务清单**:
- [ ] 创建安全设置API
- [ ] 实现IP记录管理
- [ ] 添加登录历史查询
- [ ] 创建安全设置前端页面

**API实现**:
```python
# backend/routers/security.py
router = APIRouter(prefix="/api/security", tags=["security"])

@router.get("/ip-records", response_model=List[IPLocationRecordResponse])
def get_ip_records(
    skip: int = 0,
    limit: int = 50,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的IP记录"""
    records = db.query(IPLocationRecord).filter(
        IPLocationRecord.user_id == current_user.id
    ).order_by(IPLocationRecord.created_at.desc()).offset(skip).limit(limit).all()
    
    return records

@router.get("/login-history", response_model=List[LoginHistoryResponse])
def get_login_history(
    skip: int = 0,
    limit: int = 50,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的登录历史"""
    # 从日志中提取登录记录
    login_logs = db.query(LogEntry).filter(
        LogEntry.user_id == current_user.id,
        LogEntry.action == "登录"
    ).order_by(LogEntry.created_at.desc()).offset(skip).limit(limit).all()
    
    return login_logs
```

#### 3.4 开发日志查看功能
**任务清单**:
- [ ] 创建日志查看API
- [ ] 实现日志筛选功能
- [ ] 添加日志详情查看
- [ ] 创建日志查看前端页面

**API实现**:
```python
# backend/routers/logs.py
router = APIRouter(prefix="/api/logs", tags=["logs"])

@router.get("", response_model=List[LogEntryResponse])
def get_user_logs(
    skip: int = 0,
    limit: int = 50,
    action: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的操作日志"""
    query = db.query(LogEntry).filter(LogEntry.user_id == current_user.id)
    
    if action:
        query = query.filter(LogEntry.action == action)
    
    if start_date:
        query = query.filter(LogEntry.created_at >= start_date)
    
    if end_date:
        query = query.filter(LogEntry.created_at <= end_date)
    
    logs = query.order_by(LogEntry.created_at.desc()).offset(skip).limit(limit).all()
    
    return logs
```

### 阶段4: 前端界面更新 (2-3天)

#### 4.1 创建新的HTML页面
**任务清单**:
- [ ] 创建 `balance.html` - 余额管理页面
- [ ] 创建 `usage.html` - 使用统计页面
- [ ] 创建 `security.html` - 安全设置页面
- [ ] 创建 `logs.html` - 日志查看页面

#### 4.2 更新CSS样式
**任务清单**:
- [ ] 更新 `css/balance.css` - 余额页面样式
- [ ] 更新 `css/usage.css` - 使用统计页面样式
- [ ] 更新 `css/security.css` - 安全设置页面样式
- [ ] 更新 `css/logs.css` - 日志页面样式

#### 4.3 更新JavaScript逻辑
**任务清单**:
- [ ] 创建 `js/balance.js` - 余额页面逻辑
- [ ] 创建 `js/usage.js` - 使用统计页面逻辑
- [ ] 创建 `js/security.js` - 安全设置页面逻辑
- [ ] 创建 `js/logs.js` - 日志页面逻辑

#### 4.4 更新仪表板
**任务清单**:
- [ ] 更新 `dashboard.html` - 添加余额概览
- [ ] 更新 `dashboard.js` - 添加余额统计
- [ ] 添加会员到期提醒
- [ ] 添加余额不足警告

### 阶段5: 续费功能集成 (2-3天)

#### 5.1 集成支付功能
**任务清单**:
- [ ] 创建支付API
- [ ] 集成Stripe支付
- [ ] 集成支付宝支付
- [ ] 创建支付回调处理

#### 5.2 实现会员到期提醒
**任务清单**:
- [ ] 创建会员到期检查任务
- [ ] 实现邮件提醒功能
- [ ] 添加前端提醒显示
- [ ] 测试提醒机制

#### 5.3 更新会员等级管理
**任务清单**:
- [ ] 更新会员等级定义
- [ ] 实现会员等级计算
- [ ] 添加会员状态更新
- [ ] 测试会员功能

### 阶段6: 集成测试 (1天)

#### 6.1 端到端测试
**任务清单**:
- [ ] 创建测试脚本
- [ ] 测试完整用户流程
- [ ] 测试管理员功能移除
- [ ] 测试TOTP认证流程

#### 6.2 性能测试
**任务清单**:
- [ ] 测试数据库查询性能
- [ ] 测试API响应时间
- [ ] 测试并发用户支持
- [ ] 优化性能瓶颈

#### 6.3 安全测试
**任务清单**:
- [ ] 测试认证安全性
- [ ] 测试数据加密
- [ ] 测试权限控制
- [ ] 测试漏洞扫描

#### 6.4 修复问题
**任务清单**:
- [ ] 修复发现的bug
- [ ] 优化用户体验
- [ ] 完善错误处理
- [ ] 添加日志记录

## 风险评估与缓解措施

### 技术风险

#### 1. 数据库兼容性问题
**风险**: SQLite与PostgreSQL的差异可能导致数据迁移失败
**缓解措施**:
- 使用SQLAlchemy ORM抽象数据库差异
- 创建全面的迁移脚本
- 进行充分的兼容性测试

#### 2. 性能影响
**风险**: 新增功能可能影响系统性能
**缓解措施**:
- 优化数据库查询，添加适当索引
- 实现缓存机制
- 进行性能基准测试

### 业务风险

#### 1. 用户体验变化
**风险**: 流程变更可能影响用户体验
**缓解措施**:
- 渐进式变更，提供清晰的用户引导
- 保留重要功能的便捷访问
- 收集用户反馈并及时调整

#### 2. 数据迁移风险
**风险**: 现有数据的迁移可能丢失或损坏
**缓解措施**:
- 制定详细的数据迁移计划
- 在测试环境充分验证
- 准备数据回滚方案

## 质量保证

### 代码质量
- 遵循项目现有的代码规范
- 添加适当的注释和文档
- 进行代码审查

### 测试覆盖
- 单元测试覆盖核心功能
- 集成测试验证系统交互
- 端到端测试验证用户流程

### 文档更新
- 更新API文档
- 更新用户手册
- 更新部署指南

## 项目里程碑

| 里程碑 | 时间 | 目标 |
|--------|------|------|
| 数据库重构完成 | Day 2 | SQLite兼容的数据库结构 |
| 认证流程重构完成 | Day 3 | 强制TOTP认证流程 |
| 用户功能开发完成 | Day 7 | 完整的用户功能模块 |
| 前端界面更新完成 | Day 10 | 用户友好的前端界面 |
| 续费功能集成完成 | Day 13 | 完整的续费和支付功能 |
| 集成测试完成 | Day 14 | 系统稳定性和性能验证 |

## 后续优化建议

1. **移动端适配**: 优化移动端用户体验
2. **多语言支持**: 添加国际化支持
3. **API文档**: 完善API文档和示例
4. **监控告警**: 添加系统监控和告警机制
5. **性能优化**: 持续优化系统性能
6. **功能扩展**: 根据用户反馈添加新功能

## 总结

本次重构将使系统更加用户友好和安全，同时保持良好的可维护性。通过移除管理员角色和强制TOTP认证，我们能够提供一个更加安全可靠的API密钥管理平台。重构完成后，系统将具备更好的用户体验、更高的安全性和更强的可扩展性。