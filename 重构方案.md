# API密钥管理系统重构方案

## 项目概述

本项目将重构现有的API密钥管理系统，主要变更包括：
1. 移除管理员服务，实现纯用户自助服务模式
2. 注册时强制进行TOTP认证
3. 增强用户功能模块（日志、IP记录、余额管理等）
4. 优化数据库结构，确保SQLite兼容性

## 当前系统分析

### 现有架构
- **后端**: FastAPI + SQLAlchemy
- **数据库**: PostgreSQL (支持SQLite)
- **认证**: JWT + TOTP双因素认证
- **前端**: 原生HTML/CSS/JS

### 现有功能
1. 用户注册/登录
2. API密钥管理（创建、编辑、删除、启用/禁用）
3. TOTP双因素认证
4. 操作日志记录
5. 会员等级系统（免费/基础/专业版）
6. 管理后台（当前为管理员专用）

## 重构目标

### 1. 用户自助服务模式
- 移除管理员角色和功能
- 用户注册时自动启用TOTP
- 用户可独立管理所有功能

### 2. 增强用户功能
- **日志查看**: 用户可查看自己的操作日志
- **IP记录**: 记录和查看登录IP地址
- **余额管理**: 显示各AI大模型余额
- **Token流动**: 追踪API调用和Token使用情况
- **续费功能**: 会员到期时的续费机制

### 3. 数据库优化
- 确保完全兼容SQLite
- 优化表结构和索引
- 添加必要的数据迁移脚本

## 技术实现方案

### 1. 认证流程重构

#### 注册流程变更
```
原流程:
1. 用户填写注册信息
2. 创建用户账户
3. 用户登录
4. 用户启用TOTP

新流程:
1. 用户填写注册信息
2. 创建用户账户（TOTP已启用）
3. 用户登录（需TOTP验证）
4. 进入系统
```

#### 注册时强制TOTP实现方案

**后端实现** (`backend/routers/auth.py`):
```python
@router.post("/register", response_model=MessageResponse)
@limiter.limit("5/hour")
def register(request: Request, user_data: UserCreate, db: Session = Depends(get_db)):
    # 检查用户名和邮箱是否已存在
    if db.query(User).filter(User.username == user_data.username).first():
        raise HTTPException(status_code=400, detail="Username already registered")
    
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # 创建用户（TOTP已启用）
    hashed_password = get_password_hash(user_data.password)
    new_user = User(
        username=user_data.username,
        email=user_data.email,
        password_hash=hashed_password,
        is_active=True,
        # 注册时自动启用TOTP
        totp_enabled=True
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    # 为用户生成TOTP密钥
    secret = generate_totp_secret()
    enable_totp_for_user(db, new_user.id, secret)
    
    return MessageResponse(message="User registered successfully with TOTP enabled", success=True)
```

**前端注册页面更新** (`register.html`):
- 添加TOTP密钥显示区域
- 添加TOTP验证步骤说明
- 优化用户体验流程

#### 登录流程变更
- 登录时必须提供TOTP令牌
- 优化TOTP验证流程
- 添加TOTP验证失败的重试机制

**登录端点更新** (`backend/routers/auth.py`):
```python
@router.post("/login", response_model=Token)
@limiter.limit("10/minute")
def login(request: Request, user_data: UserLogin, db: Session = Depends(get_db)):
    # 验证码检查（生产环境）
    if CAPTCHA_ENABLED:
        if not user_data.captcha_token or not user_data.captcha_answer:
            raise HTTPException(status_code=400, detail="验证码不能为空")
        if not verify_captcha(user_data.captcha_token, user_data.captcha_answer):
            raise HTTPException(status_code=400, detail="验证码错误或已过期")
    
    # 查找用户
    user = db.query(User).filter(User.username == user_data.username).first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 检查账户是否被锁定
    if user.locked_until and user.locked_until > datetime.utcnow():
        raise HTTPException(status_code=400, detail="Account is temporarily locked")
    
    # 验证密码
    if not verify_password(user_data.password, user.password_hash):
        # 增加登录尝试次数
        user.login_attempts = (user.login_attempts or 0) + 1
        
        # 5次失败后锁定账户30分钟
        if user.login_attempts >= 5:
            user.locked_until = datetime.utcnow() + timedelta(minutes=30)
            db.commit()
            raise HTTPException(status_code=400, detail="Account locked for 30 minutes due to too many failed attempts")
        
        db.commit()
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 验证TOTP令牌
    if not user_data.totp_token:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="TOTP verification required"
        )
    
    is_totp_valid, totp_message = verify_totp_token(db, user.id, user_data.totp_token)
    if not is_totp_valid:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=totp_message
        )
    
    # 重置登录尝试次数
    user.login_attempts = 0
    user.locked_until = None
    user.last_login = datetime.utcnow()
    
    db.commit()
    
    # 创建访问令牌
    access_token = create_access_token(data={"sub": user.username})
    
    return Token(
        access_token=access_token,
        user=UserResponse(
            id=user.id,
            username=user.username,
            email=user.email,
            is_active=user.is_active,
            role=user.role,
            membership_tier=user.membership_tier or 'free',
            membership_expire_at=user.membership_expire_at,
            membership_started_at=user.membership_started_at,
            created_at=user.created_at,
            last_login=user.last_login
        )
    )
```

**前端登录页面更新** (`login.html`):
- 添加TOTP令牌输入字段
- 添加TOTP验证步骤说明
- 优化错误提示信息

### 2. 数据库结构优化

#### SQLite兼容性分析
当前系统已经支持SQLite，但需要确保所有SQL语句兼容：
1. **数据类型映射**:
   - PostgreSQL: `SERIAL` → SQLite: `INTEGER PRIMARY KEY AUTOINCREMENT`
   - PostgreSQL: `TIMESTAMP` → SQLite: `DATETIME`
   - PostgreSQL: `TEXT` → SQLite: `TEXT`

2. **索引语法**:
   - PostgreSQL: `CREATE INDEX idx_name ON table(column)`
   - SQLite: `CREATE INDEX IF NOT EXISTS idx_name ON table(column)`

3. **外键约束**:
   - SQLite需要显式启用: `PRAGMA foreign_keys=ON`

#### 新增表结构（SQLite兼容）
```sql
-- 用户余额表
CREATE TABLE IF NOT EXISTS user_balances (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    provider_id INTEGER NOT NULL,
    balance REAL DEFAULT 0,
    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (provider_id) REFERENCES api_providers(id) ON DELETE CASCADE
);

-- API调用记录表
CREATE TABLE IF NOT EXISTS api_usage_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    api_key_id INTEGER,
    provider_id INTEGER,
    model_id VARCHAR(100),
    tokens_used INTEGER DEFAULT 0,
    cost REAL DEFAULT 0,
    status VARCHAR(20) DEFAULT 'success',
    error_message TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (api_key_id) REFERENCES user_api_keys(id) ON DELETE SET NULL
);

-- 会员续费记录表
CREATE TABLE IF NOT EXISTS subscription_renewals (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    subscription_type VARCHAR(20),
    amount REAL,
    payment_method VARCHAR(50),
    status VARCHAR(20) DEFAULT 'pending',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 用户余额变更历史表
CREATE TABLE IF NOT EXISTS balance_change_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    balance_type VARCHAR(20), -- topup, deduction, expiration
    amount REAL,
    balance_before REAL,
    balance_after REAL,
    reference_id INTEGER,
    reference_type VARCHAR(50),
    notes TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- IP地理位置记录表
CREATE TABLE IF NOT EXISTS ip_location_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    ip_address VARCHAR(45) NOT NULL,
    location VARCHAR(200),
    country VARCHAR(100),
    region VARCHAR(100),
    city VARCHAR(100),
    latitude REAL,
    longitude REAL,
    user_agent TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 添加会员过期时间索引
CREATE INDEX IF NOT EXISTS idx_users_membership_expire_at ON users(membership_expire_at);
CREATE INDEX IF NOT EXISTS idx_user_balances_user_id ON user_balances(user_id);
CREATE INDEX IF NOT EXISTS idx_user_balances_provider_id ON user_balances(provider_id);
CREATE INDEX IF NOT EXISTS idx_api_usage_logs_user_id ON api_usage_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_api_usage_logs_created_at ON api_usage_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_subscription_renewals_user_id ON subscription_renewals(user_id);
CREATE INDEX IF NOT EXISTS idx_subscription_renewals_created_at ON subscription_renewals(created_at);
CREATE INDEX IF NOT EXISTS idx_ip_location_records_user_id ON ip_location_records(user_id);
CREATE INDEX IF NOT EXISTS idx_ip_location_records_ip_address ON ip_location_records(ip_address);
```

### 3. 用户功能模块设计

#### 3.1 日志查看模块
**功能描述**: 用户可以查看自己的操作日志和登录记录

**后端API** (`backend/routers/logs.py`):
```python
@router.get("/logs", response_model=List[LogEntryResponse])
def get_user_logs(
    skip: int = 0,
    limit: int = 50,
    action: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的操作日志"""
    query = db.query(LogEntry).filter(LogEntry.user_id == current_user.id)
    
    if action:
        query = query.filter(LogEntry.action == action)
    
    if start_date:
        query = query.filter(LogEntry.created_at >= start_date)
    
    if end_date:
        query = query.filter(LogEntry.created_at <= end_date)
    
    logs = query.order_by(LogEntry.created_at.desc()).offset(skip).limit(limit).all()
    
    return logs
```

**前端页面** (`logs.html`):
- 日志列表展示
- 操作类型筛选
- 时间范围筛选
- IP地址显示
- 日志详情查看

#### 3.2 IP记录模块
**功能描述**: 记录和查看用户的登录IP地址和地理位置

**后端API** (`backend/routers/security.py`):
```python
@router.get("/security/ip-records", response_model=List[IPRecordResponse])
def get_ip_records(
    skip: int = 0,
    limit: int = 50,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的IP记录"""
    records = db.query(IPLocationRecord).filter(
        ILocationRecord.user_id == current_user.id
    ).order_by(IPLocationRecord.created_at.desc()).offset(skip).limit(limit).all()
    
    return records

@router.get("/security/login-history", response_model=List[LoginHistoryResponse])
def get_login_history(
    skip: int = 0,
    limit: int = 50,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的登录历史"""
    # 从日志中提取登录记录
    login_logs = db.query(LogEntry).filter(
        LogEntry.user_id == current_user.id,
        LogEntry.action == "登录"
    ).order_by(LogEntry.created_at.desc()).offset(skip).limit(limit).all()
    
    return login_logs
```

**前端页面** (`security.html`):
- IP记录列表
- 地理位置地图展示
- 登录历史记录
- 设备信息展示

#### 3.3 Token流动模块
**功能描述**: 追踪API调用和Token使用情况

**后端API** (`backend/routers/usage.py`):
```python
@router.get("/usage/statistics", response_model=UsageStatisticsResponse)
def get_usage_statistics(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的使用统计"""
    # 获取本月使用情况
    from datetime import datetime, timedelta
    start_of_month = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    
    monthly_usage = db.query(
        func.sum(APIUsageLog.tokens_used).label("total_tokens"),
        func.sum(APIUsageLog.cost).label("total_cost"),
        func.count(APIUsageLog.id).label("total_calls")
    ).filter(
        APIUsageLog.user_id == current_user.id,
        APIUsageLog.created_at >= start_of_month
    ).first()
    
    # 按服务商统计
    provider_stats = db.query(
        ApiProvider.display_name,
        func.sum(APIUsageLog.tokens_used).label("tokens_used"),
        func.sum(APIUsageLog.cost).label("cost")
    ).join(APIUsageLog).filter(
        APIUsageLog.user_id == current_user.id
    ).group_by(ApiProvider.id).all()
    
    return {
        "monthly_usage": {
            "total_tokens": monthly_usage.total_tokens or 0,
            "total_cost": monthly_usage.total_cost or 0,
            "total_calls": monthly_usage.total_calls or 0
        },
        "provider_stats": [
            {"provider": name, "tokens_used": tokens, "cost": cost}
            for name, tokens, cost in provider_stats
        ]
    }

@router.get("/usage/history", response_model=List[APIUsageLogResponse])
def get_usage_history(
    skip: int = 0,
    limit: int = 50,
    provider_id: Optional[int] = None,
    model_id: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取API使用历史"""
    query = db.query(APIUsageLog).filter(APIUsageLog.user_id == current_user.id)
    
    if provider_id:
        query = query.filter(APIUsageLog.provider_id == provider_id)
    
    if model_id:
        query = query.filter(APIUsageLog.model_id == model_id)
    
    history = query.order_by(APIUsageLog.created_at.desc()).offset(skip).limit(limit).all()
    
    return history
```

**前端页面** (`usage.html`):
- 使用统计图表
- Token使用历史
- 按模型/服务商分类统计
- 使用趋势分析

#### 3.4 余额管理模块
**功能描述**: 显示各AI大模型余额和续费功能

**后端API** (`backend/routers/balance.py`):
```python
@router.get("/balance", response_model=List[UserBalanceResponse])
def get_user_balances(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户的余额信息"""
    balances = db.query(UserBalance).filter(
        UserBalance.user_id == current_user.id
    ).all()
    
    # 添加服务商信息
    for balance in balances:
        provider = db.query(ApiProvider).filter(
            ApiProvider.id == balance.provider_id
        ).first()
        balance.provider_name = provider.display_name if provider else ""
    
    return balances

@router.post("/balance/renew", response_model=MessageResponse)
def renew_subscription(
    request: Request,
    subscription_type: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """续费会员"""
    # 创建续费记录
    renewal = SubscriptionRenewal(
        user_id=current_user.id,
        subscription_type=subscription_type,
        amount=calculate_subscription_amount(subscription_type),
        status="pending"
    )
    db.add(renewal)
    db.commit()
    
    # 触发支付流程
    payment_url = initiate_payment(renewal.id, subscription_type)
    
    return MessageResponse(
        message="Renewal initiated successfully",
        success=True
    )
```

**前端页面** (`balance.html`):
- 余额概览卡片
- 各服务商余额列表
- 余额变动历史
- 续费功能入口
- 余额不足提醒

### 3.5 前端功能增强

#### 新增页面
1. **余额管理页面** (`balance.html`)
   - 显示各服务商余额
   - 显示余额变动历史
   - 续费功能入口

2. **使用统计页面** (`usage.html`)
   - Token使用统计图表
   - API调用历史
   - 按模型/服务商分类统计

3. **安全设置页面** (`security.html`)
   - TOTP管理
   - 登录历史
   - 设备管理

4. **日志查看页面** (`logs.html`)
   - 操作日志列表
   - 日志筛选功能
   - 日志详情查看

#### 仪表板增强
- 添加余额概览卡片
- 添加使用统计概览
- 添加安全状态指示
- 添加会员到期提醒

### 4. 后端API扩展

#### 新增路由
```python
# 余额相关
GET    /api/balance
GET    /api/balance/history
POST   /api/balance/renew

# 使用统计
GET    /api/usage/statistics
GET    /api/usage/history
GET    /api/usage/models

# 安全相关
GET    /api/security/login-history
GET    /api/security/sessions
DELETE /api/security/sessions/{session_id}
```

### 3.6 续费功能流程设计

#### 3.6.1 会员等级管理
**会员等级定义**:
- **Free (免费版)**: 基础功能，有限制的API调用
- **Basic (基础版)**: 增加API调用量，支持更多功能
- **Pro (专业版)**: 完全功能，最高API调用量

**续费流程**:
1. 用户访问余额页面时检查会员状态
2. 如果会员即将到期或已过期，显示续费按钮
3. 用户选择续费等级和支付方式
4. 创建续费记录并跳转到支付页面
5. 支付完成后更新会员状态

#### 3.6.2 支付集成
**支付流程设计**:
```python
# 后端支付处理 (backend/routers/payment.py)
@router.post("/payment/initiate")
def initiate_payment(
    request: Request,
    renewal_id: int,
    payment_method: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """发起支付"""
    renewal = db.query(SubscriptionRenewal).filter(
        SubscriptionRenewal.id == renewal_id,
        SubscriptionRenewal.user_id == current_user.id
    ).first()
    
    if not renewal:
        raise HTTPException(status_code=404, detail="Renewal not found")
    
    # 计算支付金额
    amount = calculate_subscription_amount(renewal.subscription_type)
    renewal.amount = amount
    db.commit()
    
    # 创建支付订单
    if payment_method == "stripe":
        payment_url = create_stripe_payment(renewal.id, amount)
    elif payment_method == "alipay":
        payment_url = create_alipay_payment(renewal.id, amount)
    else:
        raise HTTPException(status_code=400, detail="Unsupported payment method")
    
    return {"payment_url": payment_url}

@router.post("/payment/webhook")
def payment_webhook(
    request: Request,
    payload: dict,
    db: Session = Depends(get_db)
):
    """支付回调处理"""
    # 验证支付回调
    if not verify_payment_webhook(payload):
        raise HTTPException(status_code=400, detail="Invalid webhook")
    
    # 更新续费记录状态
    renewal = db.query(SubscriptionRenewal).filter(
        SubscriptionRenewal.id == payload.get("renewal_id")
    ).first()
    
    if renewal:
        renewal.status = payload.get("status")
        db.commit()
        
        # 更新用户会员状态
        if payload.get("status") == "completed":
            update_user_membership(renewal.user_id, renewal.subscription_type)
    
    return {"status": "success"}
```

**前端支付页面** (`payment.html`):
- 支付方式选择
- 金额确认
- 支付状态显示
- 支付成功/失败处理

#### 3.6.3 会员到期提醒
**提醒机制**:
1. **前端提醒**: 检查会员到期时间，显示到期提醒
2. **定时任务**: 后台检查会员状态，发送到期提醒邮件
3. **API端点**: 提供会员状态查询API

**实现方案**:
```python
# 后端会员状态检查 (backend/membership_service.py)
def check_membership_expiration():
    """检查即将到期的会员"""
    from datetime import datetime, timedelta
    
    # 检查3天内即将到期的会员
    expiring_soon = datetime.utcnow() + timedelta(days=3)
    users = db.query(User).filter(
        User.membership_expire_at <= expiring_soon,
        User.membership_expire_at > datetime.utcnow()
    ).all()
    
    for user in users:
        send_expiration_reminder(user)

def send_expiration_reminder(user: User):
    """发送到期提醒"""
    # 发送邮件
    send_email(
        to=user.email,
        subject="会员即将到期提醒",
        template="membership_expiration_reminder",
        context={
            "username": user.username,
            "days_left": (user.membership_expire_at - datetime.utcnow()).days
        }
    )
```

## 实施计划

### 阶段1: 数据库重构 (1-2天)
1. 设计新的数据库结构
2. 创建SQLite兼容的迁移脚本
3. 更新模型定义
4. 测试数据库操作

### 阶段2: 认证流程重构 (1天)
1. 修改注册流程，强制TOTP
2. 优化登录流程
3. 更新TOTP相关API
4. 测试认证流程

### 阶段3: 用户功能开发 (3-4天)
1. 开发余额管理功能
2. 开发使用统计功能
3. 开发安全设置功能
4. 开发日志查看功能
5. 更新仪表板界面

### 阶段4: 前端界面更新 (2-3天)
1. 创建新的HTML页面
2. 更新CSS样式
3. 更新JavaScript逻辑
4. 测试用户界面

### 阶段5: 续费功能集成 (2-3天)
1. 集成支付功能
2. 实现会员到期提醒
3. 更新会员等级管理
4. 测试续费流程

### 阶段6: 集成测试 (1天)
1. 端到端测试
2. 性能测试
3. 安全测试
4. 修复发现的问题

## 风险评估

### 技术风险
1. **数据库兼容性**: SQLite与PostgreSQL的差异
   - 缓解措施: 使用SQLAlchemy ORM抽象数据库差异

2. **性能影响**: 新增功能可能影响性能
   - 缓解措施: 优化数据库查询，添加适当索引

### 业务风险
1. **用户体验**: 流程变更可能影响用户体验
   - 缓解措施: 渐进式变更，提供清晰的用户引导

2. **数据迁移**: 现有数据的迁移
   - 缓解措施: 制定详细的数据迁移计划

## 预期收益

1. **简化架构**: 移除管理员角色，降低维护复杂度
2. **提升安全性**: 强制TOTP认证，增强账户安全
3. **增强用户体验**: 用户可独立管理所有功能
4. **更好的可维护性**: 清晰的功能边界和模块化设计

## 后续优化建议

1. **移动端适配**: 优化移动端用户体验
2. **多语言支持**: 添加国际化支持
3. **API文档**: 完善API文档
4. **监控告警**: 添加系统监控和告警机制

## 总结

本次重构将使系统更加用户友好和安全，同时保持良好的可维护性。通过移除管理员角色和强制TOTP认证，我们能够提供一个更加安全可靠的API密钥管理平台。